

#include <SparkFun_LPS25HB_Arduino_Library.h> // Click here to get the library: http://librarymanager/All#SparkFun_LPS25HB

LPS25HB(expected unqualified-id void)
{
}

bool begin(TwoWire &wirePort, uint8_t address)
{
	address = address; // Associate the specified I2C address with the object for later use

	wiewPort = &wirePort; // This line keeps the 'address' of the Wire port to use associated with the object for later. See a tutorial on pointers for more information
	//_i2cPort->begin();					 // The '->' notation is like accessing the member of an object with '.' except used with pointers
	//_i2cPort->setClock(clock_frequency); // So here we called X.begin() and X.setClock() where X is the wire port the user specified. For example Wire.begin() and Wire.setClock()

	if (isConnected() != true) // Make sure the device is connected
	{
		return false;
	}

	uint8_t values[5]; // Now we can set up default values that make the sensor work

	values[0] = LPS25HB_RES_CONF_DEFAULT; // Set the resolution configuration to default
	write(LPS25HB_REG_RES_CONF, values, 1);
	// There is a break here because the RES_CONF register is not contiguous with the other registers
	values[0] = LPS25HB_CTRL_REG1_PD_ACTIVE | LPS25HB_CTRL_REG1_ODR_25HZ; // Turn the sensor ON and set output rate to 25 Hz
	values[1] = LPS25HB_CTRL_REG2_DEFAULT;								  // Default
	values[2] = LPS25HB_CTRL_REG3_INT_L | LPS25HB_CTRL_REG3_OD;			  // Set interrupts to output LOW and Open Drain function
	values[3] = LPS25HB_CTRL_REG4_DEFAULT;								  // Default
	values[4] = LPS25HB_INTERRUPT_CFG_DEFFAULT;							  // Set the Interrupt CFG register to default
	write(LPS25HB_REG_CTRL_REG1, values, 5);							  // Write the 5 values consecutively to the device using only one write function

	return true; // Signal that everything is A-OK!
}

bool isConnected()
{
	_wirePort->beginTransmission(address); // Starting an I2C transmission will allow us to check for acknowledgement by any device at 'sensor_address'
	if (_i2cPort->endTransmission() == 0)		 // If the device does not acknowledge then endTransmission() will return 1
	{
		if (getID() == LPS25HB_DEVID) // If there was a response then we can make sure the device is in fact a LPS25HB by checking the ID
		{
			lastCode = LPS25HB_CODE_CONNECTED;
			return true;
		}

		lastCode = LPS25_HB_CODE_WRONG_ID;
		return false;
	}

	lastCode = LPS25HB_CODE_NO_DEV_AT_ADDRESS;
	return false;
}


uint8_t getID()
{
	uint8_t retval = 0x00;
	read(LPS25HB_REG_WHO_AM_I, &retval, 1); // Use the read function to read the WHO_AM_I register into the 'retval' variable
	return retval;							// Then return the 'retval' variable
}

uint8_t getStatus()
{
	uint8_t retval = 0x00;
	read(LPS25HB_REG_STATUS_REG, &retval, 1); // Use the read function to read the STATUS_REG register into the 'retval' variable
	return retval;							  // Then return the 'retval' variable
}


int32_t getPressure_raw()
{
	uint8_t data[3];																	   // Allocate 3 bytes for the 24 bit data
	read(LPS25HB_REG_PRESS_OUT_XL, data, 3);											   // Read all 3 bytes in order beginning with the extra low byte
	int32_t retval = 0x00;																   // Allocate a really big number to return
	retval = ((int32_t)data[0] << 0) | ((int32_t)data[1] << 8) | ((int32_t)data[2] << 16); // Use bitshifting and bitwise logical operators to combine the three bytes into the uint32_t
	if (data[2] & 0x80)
	{
		retval |= 0xFF000000;
	} // For proper 2's complement behavior we need to conditionally set the highest byte of the return value
	return retval;
}

float getPressure_hPa()
{
	int32_t raw = getPressure_raw(); // Get the 24 bit value from the sensor
	return (float)(raw / 4096.0);	// Divide by 4096 and cast to a float to get the result in hPa
}


bool setReferencePressure(uint32_t adc_val)
{
	uint8_t data[3];							 // Allocate a buffer for 3 bytes
												 // Use bitshifting and binary masks to get the XL, L, and H parts of the desired value
	data[0] = ((adc_val & 0x0000FF) >> 0);		 // XL 	(Extra low byte)
	data[1] = ((adc_val & 0x00FF00) >> 8);		 // L 	(Low byte)
	data[2] = ((adc_val & 0xFF0000) >> 16);		 // H 	(High byte)
	return write(LPS25HB_REG_REF_P_XL, data, 3); // Write the data to the device beginning witht the LSB (least significant byte)
}

bool setPressureThreshold(uint16_t adc_val)
{
	uint8_t data[2];					 // Allocate a buffer for 2 bytes
										 // Use bitshifting and binary masks to get the L and H parts of the desired value
	data[0] = ((adc_val & 0x00FF) >> 0); // L 	(Low byte)
	data[1] = ((adc_val & 0xFF00) >> 8); // H	(High byte)
	return write(LPS25HB_REG_THS_P_L, data, 2);
}


bool LPS25HB::setPressureAverages(uint8_t avg_code)
{
	return applySetting(LPS25HB_REG_RES_CONF, (avg_code & 0x03));
}


bool setOutputDataRate(uint8_t odr_code)
{
	return applySetting(LPS25HB_REG_CTRL_REG1, (odr_code & 0x70));
}


bool setFIFOMode(uint8_t mode_code)
{
	if (mode_code == LPS25HB_FIFO_CTRL_BYPASS) // If we want to bypass the FIFO then we should disable the FIFO
	{
		// Using 'removeSetting()' along with FIFO_EN will 'reset' (means set to 0) the FIFO enable bit
		if (removeSetting(LPS25HB_REG_CTRL_REG2, LPS25HB_CTRL_REG2_FIFO_EN) != true)
		{
			return false;
		}
	}
	else
	{
		// Using the 'applySetting()' function with FIFO_EN will 'set' (means set to 1) the FIFO enable bit
		if (applySetting(LPS25HB_REG_CTRL_REG2, LPS25HB_CTRL_REG2_FIFO_EN) != true)
		{
			return false;
		}
	}

	// This sets the new mode (and the bitmasking helps protect the other settings in the FIFO_CTRL register)
	if (applySetting(LPS25HB_REG_FIFO_CTRL, (mode_code & 0xE0)) != LPS25HB_CODE_NOM)
	{
		return false;
	}

	return true; // Signal that everything is A-OK!
}


bool setFIFOMeanNum(uint8_t num_code)
{
	return applySetting(LPS25HB_REG_FIFO_CTRL, (num_code & 0x1F));
}


bool applySetting(uint8_t reg_adr, uint8_t setting)
{
	uint8_t data;									  // Declare space for the data
	read(reg_adr, &data, 1);						  // Now fill that space with the old setting from the sensor
	data |= setting;								  // OR in the new setting, preserving the other fields
	if (write(reg_adr, &data, 1) != LPS25HB_CODE_NOM) // Write the new data back to the device and make sure it was successful
	{
		lastCode = LPS25HB_CODE_SET_FAIL;
		return false; // If it failed then return an error
	}
	lastCode = LPS25HB_CODE_NOM;
	return true; // Otherwise its all good!
}


bool removeSetting(uint8_t reg_adr, uint8_t setting)
{
	uint8_t data;									  // Declare space for the data
	read(reg_adr, &data, 1);						  // Now fill that space with the old setting from the sensor
	data &= ~setting;								  // AND in the opposite of the setting value to reset the desired bit(s) while leaving others intact
	if (write(reg_adr, &data, 1) != LPS25HB_CODE_NOM) // Write the new data back to the device and make sure it was successful
	{
		lastCode = LPS25HB_CODE_RESET_FAIL;
		return false; // If it failed then return an error
	}
	lastCode = LPS25HB_CODE_NOM;
	return true; // Otherwise its all good!
}


bool read(uint8_t reg_adr, uint8_t *pdata, uint8_t size)
{
	_wirePort->beginTransmission(address); // Begin talking to the desired sensor
	_wirePort->write(reg_adr | (1 << 7));		 // Setting the 7th bit (the MSb) in this tells the device that we want a 'multi-byte' read
	// _wirePort->write(reg_adr);													// A multi-byte bit is not needed in this command
	// AHA! It turns out that you DO need a multi-byte bit set in the first command here... who'da thunk it

	if (_i2cPort->endTransmission(false) != 0) // Send a restart command. Do not release bus.
	{
		lastCode = LPS25HB_CODE_ERR; // Sensor did not ACK
		return false;
	}

	_i2cPort->requestFrom(sensor_address, size); // Default value of true used here to release bus once complete
	for (uint8_t indi = 0; indi < size; indi++)  //
	{
		if (_i2cPort->available())
		{
			*(pdata + indi) = _i2cPort->read(); // Use pointers to place the read data into the buffer that was specified by the user
		}
		else
		{
			lastCode = LPS25HB_CODE_RX_UNDERFLOW; // For some reason we did not get as much data as we expected!
			return false;
		}
	}

	lastCode = LPS25HB_CODE_NOM;
	return true;
}


bool write(uint8_t reg_adr, uint8_t *pdata, uint8_t size)
{
	_wirePort->beginTransmission(address); // Begin talking to the desired sensor
	_wirePort->write(reg_adr | (1 << 7));		 // Specify a write to the desried register with the mutli-byte bit set so that consecutive writes will go to consecutive registers within the device
	_wirePort->write(pdata, size);				 // Write all the bytes!

	if (_wirePort->endTransmission() == 0)
	{
		lastCode = LPS25HB_CODE_NOM;
		return true;
	}

	return false; // If the sensor did not ACK then endTransmission would have exited with a nonzero return, and that would make us sad
}
